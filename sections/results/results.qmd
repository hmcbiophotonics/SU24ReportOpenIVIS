---
title: Results
output: index
jupyter: python3
header-includes:
  - \setcounter{page}{5}  
---


## System Verification and Setup {#system-verification-and-setup}

### Changing Exposure Time

In Fig. #, there is a positive, non-linear relationship between exposure time and pixel intensity. Initially there is a large increase in pixel intensity as exposure time increases and this is most likely because as exposure time increases, more photons will be detected by the pixels in the camera. As exposure time continues to increase, the increase in pixel intensity starts to decrease. This is most likely because the pixels can only hold a certain amount of photons and when a pixel has stored its maximum amount of photons, it has reached its saturation point. As more photons are being detected by the pixels from the increasing exposure times, the pixels are getting closer to their saturation point (Hasinoff). This plot also has a small error across the different trials, suggesting that the exposure times are precise.

### Changing Brightness Level

In both of the plots shown in Fig. #, there is a positive trend between brightness level and pixel intensity. When the exposure time was set to 0.01 seconds (Fig. # a), the pixel intensity increases linearly and then flattens out around 600 arbitrary units. This number matches with the intensity when exposure time is 0.01 seconds in Fig. # above, suggesting that the exposure time has a significant impact on the resulting plot of brightness level vs pixel intensity. When the exposure time is increased to 0.1 seconds in Fig. # b, the linear portion of the graph seems to shift to higher brightness levels and starts to flatten out around 1000 arbitrary units. This intensity value also agrees with the intensity value of an exposure time of 0.1 seconds in Fig. # above. The trend that this data supports is that the camera will most accurately capture LED brightness when the brightness level is low and the exposure time is quick and when the brightness level is high and the exposure time is slow. There is also a very small error across the different trials, suggesting that the camera is capturing the LED brightness precisely.

### Measuring From a Photodiode

Both plots in Fig. # depict a positive, non-linear relationship between brightness and wattage from the photodiode. Fig. # a shows increasing brightness level from the NeoPixel controls while Figure # b shows increasing tuple value, or color code value. The plots are extremely similar in both shape and in error. The error across the different trials are a lot larger than in Fig.s # and #. This is because the photodiode is measuring the actual LED output rather than what the camera is capturing the brightness to be. The LEDs being used are off the shelf and relatively cheap, so it was expected that they would be less precise than more expensive LED options.

## Flourescence Imaging  {#fluorescence-imaging}

Fig. # shows the normalized pixel intensities of all ten concentrations of FITC for eight different exposure times. As exposure time and concentration increases, the pixel intensity also increases. The 100 milliseconds, or 0.1 seconds, exposure time best represents the expected relationship between concentration and pixel intensity (green curve). As seen in Fig. #, the lower concentrations of FITC are a lot less fluorescent than the higher concentrations. The green curve shows a large increase in pixel intensity in the higher concentrations, with it flattening out at the maximum value of 1 in the normalized plot. This maximum value of 1 corresponds to 1023 arbitrary units. The slower exposure times (purple and blue curves) also show the trend to an extent. These larger exposure times mean that the images captured by the camera are super bright, so most of the concentrations have large intensity values. The faster exposure times have the opposite effect. The images captured by the camera are super dark, and the pixel intensity values are low. The intensity values for each concentration represent how fluorescent each concentration is. Based on this data, the higher concentrations of FITC are more fluorescent than the lower concentrations.

## Laser Speckle Contrast Imaging  {#laser-speckle-contrast-imaging}

### Simulation

Using the process described in Section 3.3.3, analysis on simulated speckle images and the effect of filtering was run. Fig. # depicts the simulated results for a filter with cutoff frequency of N4, where N denotes the size of the speckle image in pixels, while Figures # and # show the results for cutoff frequency of N8 and N16, respectively. 

#### Create a Simulated Speckle Image

```{python}
# Import the necessary Python packages
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import os
from PIL import Image

def ft2(im):
    """
    Takes the fourier transform
    """
    return np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(im)))

# Function for Inverse Fourier Transform
def ift2(im):
    """
    Takes the inverse fourier transform
    """
    return np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(im)))

# Generate a speckle pattern
N = 255  # Size of the speckle pattern
a = np.random.randn(N, N) + 1j * np.random.randn(N, N)
```

#### Create a filter and Apply it to the Speckle Image

```{python}
# Compute amplitude, phase and intensity of the original speckle pattern
amplitude = np.abs(a)
phase = np.angle(a)
intensity = amplitude **2

# Fourier transform of the speckle field
A = ft2(a)
# Create a circular low-pass filter
x = np.linspace(-N/2, N/2, N)
y = np.linspace(-N/2, N/2, N)
X, Y = np.meshgrid(x, y)
radius = np.sqrt(X**2 + Y**2)
cutoff = N/4  # Adjust the cutoff frequency to control the speckle size
filter = radius < cutoff

# Apply the low-pass filter
A_filtered = A * filter

# Inverse Fourier transform back to the spatial domain
a_filtered = ift2(A_filtered)


# Compute the amplitude, phase and intensity of the filtered speckle pattern
amplitude_filtered = np.abs(a_filtered)
phase_filtered = np.angle(a_filtered)
intensity_filtered = amplitude_filtered **2

```

#### Compute the Autocorrelation and Speckle Size
```{python}

# Compute autocorrelation of the original and filtered speckle patterns
autocorrelation_original = ift2(ft2(intensity) * np.conj(ft2(intensity)))
autocorrelation_filtered = ift2(ft2(intensity_filtered) * np.conj(ft2(intensity_filtered)))

autocorrelation_original = np.abs(autocorrelation_original)  # Take the magnitude
autocorrelation_filtered = np.abs(autocorrelation_filtered)  # Take the magnitude

# Normalize the autocorrelations for better visualization
autocorrelation_original /= autocorrelation_original.max()
autocorrelation_filtered /= autocorrelation_filtered.max()

# The code below is for finding the speckle sizes of the images

# Get the slice of the autocorrelation in line with the peak
central_slice_original = autocorrelation_original[N//2, :]
central_slice_filtered = autocorrelation_filtered[N//2, :]

# Find the halfway point between the maximum and the steady state
half_max_original = ((central_slice_original.max() - central_slice_original.min()) / 2 ) + central_slice_original.min()
half_max_filtered = ((central_slice_filtered.max() - central_slice_filtered.min()) / 2 ) + central_slice_filtered.min()

# Find all of the pixels above the halfway point
indices_original = np.where(central_slice_original >= half_max_original)[0]
indices_filtered = np.where(central_slice_filtered >= half_max_filtered)[0]

# Find the width of the peak at the halfway point
if indices_original.size == 1:
	speckle_size_original = 1
else:
	speckle_size_original = indices_original[-1] - indices_original[0]
	
if indices_filtered.size == 1:
	speckle_size_filtered = 1
else:
	speckle_size_filtered = indices_filtered[-1] - indices_filtered[0]

# Print the speckle sizes
print(f"Original speckle size (width at half maximum): {speckle_size_original} pixels")
print(f"Filtered speckle size (width at half maximum): {speckle_size_filtered} pixels")


# Rayleigh Distribution for the amplitude histograms
flat = np.abs(amplitude.flatten())
flat_fil = np.abs(amplitude_filtered.flatten())

sigma = np.sqrt(np.mean(flat**2) / 2)
sigma_fil = np.sqrt(np.mean(flat_fil**2) / 2)

x = np.linspace(0, np.max(flat), 255)
x_fil = np.linspace(0, np.max(flat_fil), 255)

ray = (x / sigma**2) * np.exp(-x**2 / (2 * sigma**2))
ray_fil = (x_fil / sigma_fil**2) * np.exp(-x_fil**2 / (2 * sigma_fil**2))


# Zoom into the autocorrelations
zoom = 100
center = np.array(autocorrelation_original.shape) // 2
center_fil = np.array(autocorrelation_filtered.shape) // 2

zoomRegion = (slice(center[0]-zoom, center[0]+zoom), slice(center[1]-zoom, center[1]+zoom))
zoomRegion_fil = (slice(center_fil[0]-zoom, center_fil[0]+zoom), slice(center_fil[1]-zoom, center_fil[1]+zoom))

autoZoom = autocorrelation_original[zoomRegion]
autoZoom_fil = autocorrelation_filtered[zoomRegion_fil]
```

#### Create plots
```{python}

def add_colorbar(him, ax, cbar_title=""):
    """
    This function adds a nicely-formatted colorbar
    """
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    cbar = plt.colorbar(him, cax=cax)
    cbar.set_label(cbar_title, rotation=270, labelpad=15)

# Figure for all of the original speckle pattern info
fig, o = plt.subplots(ncols=3, nrows=2, figsize=(20,18))

# Plot the original amplitude
im_amp = o[0, 0].imshow(amplitude, cmap='gray')
o[0, 0].set_title('Original Speckle Field Amplitude')
add_colorbar(im_amp, o[0, 0], "Amplitude [a.u.]")

# Plot the original phase
im_phase = o[0, 1].imshow(phase, cmap='gray')
o[0, 1].set_title('Original Speckle Field Phase')
add_colorbar(im_phase, o[0, 1], "Phase [rad]")

# Plot the original intensity
im_int = o[0, 2].imshow(intensity, cmap='gray')
o[0, 2].set_title('Original Speckle Field Intensity')
add_colorbar(im_int, o[0, 2], "Intensity [a.u.]")

# Plot histogram of the original amplitude with Rayleigh
o[1, 0].hist(flat, bins=50, density=True, color='black', label='Speckle Amplitude')
o[1, 0].plot(x, ray, 'r-', lw=2, label='Rayleih Fit')
o[1, 0].set_title('Histogram of Original Amplitude')
o[1, 0].set_xlabel('Amplitude [a.u.]')
o[1, 0].set_ylabel('Frequency')

# Plot histogram of the original phase
o[1, 1].hist(phase.ravel(), bins=50, color='black')
o[1, 1].set_title('Histogram of Original Phase')
o[1, 1].set_xlabel('Phase [rad]')
o[1, 1].set_ylabel('Frequency')

# Plot histogram of the original intensity
o[1, 2].hist(intensity.ravel(), bins=50, color='black')
o[1, 2].set_title('Histogram of Original Intensity')
o[1, 2].set_xlabel('Intensity [a.u.]')
o[1, 2].set_ylabel('Frequency')

# Figure for all of the filtered speckle pattern info
fig, f = plt.subplots(ncols=3, nrows=2, figsize=(20,18))

# Plot the filtered amplitude
im_amp_filtered = f[0, 0].imshow(amplitude_filtered, cmap='gray')
f[0, 0].set_title('Filtered Speckle Field Amplitude')
add_colorbar(im_amp_filtered, f[0, 0], "Amplitude [a.u.]")

# Plot the filtered phase
im_phase_filtered = f[0, 1].imshow(phase_filtered, cmap='gray')
f[0, 1].set_title('Filtered Speckle Field Phase')
add_colorbar(im_phase_filtered, f[0, 1], "Phase [rad]")

# Plot the filtered intensity
im_int_filtered = f[0, 2].imshow(intensity_filtered, cmap='gray')
f[0, 2].set_title('Filtered Speckle Field Intensity')
add_colorbar(im_int_filtered, f[0, 2], "Intensity [a.u.]")

# Plot histogram of the filtered amplitude with Rayleigh
f[1, 0].hist(flat_fil, bins=50, density=True, color='black', label='Speckle Amplitude')
f[1, 0].plot(x_fil, ray_fil, 'r-', lw=2, label='Rayleih Fit')
f[1, 0].set_title('Histogram of Filtered Amplitude')
f[1, 0].set_xlabel('Amplitude [a.u.]')
f[1, 0].set_ylabel('Frequency')

# Plot histogram of the filtered phase
f[1, 1].hist(phase_filtered.ravel(), bins=50, color='black')
f[1, 1].set_title('Histogram of Filtered Phase')
f[1, 1].set_xlabel('Phase [rad]')
f[1, 1].set_ylabel('Frequency')

# Plot histogram of the filtered intensity
f[1, 2].hist(intensity_filtered.ravel(), bins=50, color='black')
f[1, 2].set_title('Histogram of Filtered Intensity')
f[1, 2].set_xlabel('Intensity [a.u.]')
f[1, 2].set_ylabel('Frequency')

# Fiure fo comparing the autocorrelations of the original and filtered speckle patterns
fig, a = plt.subplots(ncols=2, nrows=3, figsize=(10,20))

# Plot the original amplitude
im_amp = a[0, 0].imshow(amplitude, cmap='gray')
a[0, 0].set_title('Original Speckle Field Amplitude')
add_colorbar(im_amp, a[0, 0], "Amplitude [a.u.]")

# Plot the filtered amplitude
im_amp_filtered = a[0, 1].imshow(amplitude_filtered, cmap='gray')
a[0, 1].set_title('Filtered Speckle Field Amplitude')
add_colorbar(im_amp_filtered, a[0, 1], "Amplitude [a.u.]")

# Plot the autocorrelation of the original speckle pattern
im_autoZoom = a[1, 0].imshow(autoZoom, cmap='gray')
a[1, 0].set_title('Autocorrelation of Original Speckle Pattern')
add_colorbar(im_autoZoom, a[1, 0], "Intensity [a.u.]")

# Plot the autocorrelation of the filtered speckle pattern
im_autoZoom_fil = a[1, 1].imshow(autoZoom_fil, cmap='gray')
a[1, 1].set_title('Autocorrelation of Filtered Speckle Pattern')
add_colorbar(im_autoZoom_fil, a[1, 1], "Intensity [a.u.]")

# Plot the central slice of the original autocorrelation (zoomed)
a[2,0].plot(central_slice_original, color='black')
a[2,0].axhline(y=half_max_original, color='red', linestyle='--')
a[2,0].set_title('Central Slice of Original Autocorrelation')
a[2,0].set_xlabel('Pixel')
a[2,0].set_ylabel('Intensity [a.u.]')
a[2,0].text(0.5, 0.9, f'Speckle size: {speckle_size_original} pixels', color='red', transform=a[2,0].transAxes)

# Plot the central slice of the filtered autocorrelation (zoomed)
a[2,1].plot(central_slice_filtered, color='black')
a[2,1].axhline(y=half_max_filtered, color='red', linestyle='--')
a[2,1].set_title('Central Slice of Filtered Autocorrelation')
a[2,1].set_xlabel('Pixel')
a[2,1].set_ylabel('Intensity [a.u.]')
a[2,1].text(0.5, 0.9, f'Speckle size: {speckle_size_filtered} pixels', color='red', transform=a[2,1].transAxes)

# Adjust layout
plt.tight_layout()
# Show the plot
plt.show()

```

As the cutoff frequency decreases, the size of the speckle in pixels increases. The original speckle pattern has a speckle size of 1. A cutoff frequency of N4 results in a filtered speckle size of 2 pixels, N8 results in a filtered speckle size of 4 pixels, and N16 results in a filtered speckle size of 8 pixels, as shown in Figures #x, #x, and #x. This implies that the filter size directly affects the resulting speckle size and a more narrow filter will produce a lower resolution image, but may decrease the noise in the speckle pattern. Additionally, as the filter's cutoff frequency decreases, the amplitude histogram of the filtered patterns intensity decreases. Fig. #x shows a normalized amplitude peak at approximately 1 for a cutoff frequency of N4, while Fig. #x shows an amplitude peak at 0.1 for a cutoff frequency of N16. The simulated results also show an increase in autocorrelation with a decrease in cutoff frequency, as shown in Figures #x, #x, and #x. The change in autocorrelation is indicative of the change in speckle size across the simulations. In real-world applications, an increase in autocorrelation across images may also imply differences in the subject's roughness or uniformity.

### Physical Tests
The LSCI analysis script was run on images with a cream and water mixture running through the tube at flow rates of XX ml/hr, XX ml/hr, XX ml/hr, and XX ml/hr. The resulting speckle images, LSCI reproductions and intensity histograms are shown in Figures #, #, #, and #. 

MORE ONCE WE HAVE CONCLUSIVE RESULTS…

## Additional Capabilities

The system was successful in taking time lapse images over an extended period of time and could be used for a broad range of biological imaging applications. The time lapse of the Tobacco Hornworm growth resulted in 45 images over the span of 9 days, with 5 hours between each image. An example of one week’s worth of growth is shown in Fig. #, and an image of the full box on the first and last day is shown in Fig. #. 
While the OpenIVIS system was able to take images of lettuce leaf decomposition over a three day period, the anthocyanin response was not able to be determined. The response imaged on the 1st and 3rd days of the trial are shown in Fig. # and #. The anthocyanin response is very similar between the two images, and discernible changes are not able to be visualized. It is possible that the type of lettuce being imaged does not have a strong enough concentration of anthocyanin to properly fluoresce, resulting in similar results. Additionally, due to limited documentation on how to conduct this experiment, the experimental process and calculations used may be incorrect. An accurate depiction of this trial is shown in the system’s previous publication by Branning et. al [Branning].


