[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "OpenIVIS Summer 2024 Report",
    "section": "",
    "text": "Table of Contents\n\nIndex\nAbstract\nIntroduction\n     3.1 In Vivo Imaging Systems\n     3.2 Fluorescence Imaging\n     3.3 Laser Speckle Contrast Imaging\n\nMethods\n     4.1 Physical construction\n     4.2 Electrical Components and Software\n     4.3 Experiments\n\nResults\n     5.1 System Verification and Setup\n     5.2 Flourescence Imaging\n     5.3 Laser Speckle Contrast Imaging\n     5.4 Additional Capabailities\n\nConclusion\nAcknowledgements\nAppendix",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>OpenIVIS Summer 2024 Quarto Report</span>"
    ]
  },
  {
    "objectID": "sections/abstract/index.html",
    "href": "sections/abstract/index.html",
    "title": "2  Abstract",
    "section": "",
    "text": "This paper presents the continuation of the design of an open source, inexpensive, and modular In Vivo Imaging System (IVIS) from the Harvey Mudd Biophotonics Lab during the summer of 2024. The authors contributions include the implementation of fluorescence imaging and laser speckle imaging on an improved physical system design. The system was created using widely available materials and tools including acrylic, a laser cutter, a 3D printer, and a Raspberry Pi computer. The experiments done to verify fluorescence imaging resulted in the expected relationship between fluorescence and fluorescent dye concentrations with a set exposure time of 0.1 seconds. The experiments done to implement and verify laser speckle imaging have assisted in the development of its abilities as an IVIS imaging method, but need further work to provide accurate results. The results from the experiments demonstrate the improved capabilities of the new IVIS system and pathways for future developments.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Abstract</span>"
    ]
  },
  {
    "objectID": "sections/introduction/index.html",
    "href": "sections/introduction/index.html",
    "title": "3  Introduction",
    "section": "",
    "text": "3.1 In Vivo Imaging Systems\nIn Vivo Imaging Systems (IVIS) are optical imaging devices used in scientific research to create 2D and 3D representations of biological organisms and processes non-invasively. These systems use advanced imaging techniques, such as bioluminescence and fluorescence imaging, to visualize and track various biological activities within an organism over time. This approach to optical imaging can assist in drug development, understanding disease behaviors, or other biological processes in their natural context [1]. Most IVIS Imaging methods implement optics in order to extract information about a subject based on the optical properties of the subject and the technique being applied. Many commercial IVIS systems can provide additional capabilities such as X-Ray, temperature control, computed tomography (CT), or accessories [2].\nWhile IVIS systems are able to create detailed images over a broad range of applications, they can be limiting due to their inaccessibility. IVIS systems tend to cost upwards of $100,000, which may bar smaller or less-funded research institutions from purchasing their own system [3]. Renting the use of an IVIS system is typically in the hundreds of dollars range as well, which further restricts the accessibility of in vivo imaging [4]. In addition to being high-cost, commercial IVIS systems are also restricted to the imaging applications they’ve been developed for with little room for customization or modularity.\nThe goal of the OpenIVIS project is to create a low-cost, open source and modular version of an IVIS system for biological imaging. Free open-source software (FOSS), free open-source hardware (FOSH) and the increased accessibility of rapid prototyping techniques, such as 3-dimensional (3D) printing, would allow for any institution to implement a version of this system in their research. An IVIS system with a modular design would also permit users to replace the imaging techniques used in order to best advance their work. Additionally, this would pave the way for implementation of in-vivo imaging techniques not currently available in most commercial systems such as Laser Speckle Contrast Imaging (LSCI). SHOULD maybe reference previous work on this, especially the CSM/HMC paper.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "sections/introduction/index.html#fluorescence-imaging",
    "href": "sections/introduction/index.html#fluorescence-imaging",
    "title": "3  Introduction",
    "section": "3.2 Fluorescence Imaging",
    "text": "3.2 Fluorescence Imaging\nOne of the most common capabilities of IVIS systems is fluorescence imaging. Fluorescence is a highly sensitive analytical tool that is used to measure extremely low concentrations of a compound in a solution [5]. The Jablonski diagram shown in Fig. 3.1 depicts the fluorescent process. When light is absorbed by a compound, molecules of that compound will become excited and raise to a higher energy level. Fluorescent compounds usually contain conjugated double bonds, where a certain number of electrons have greater mobility than the other electrons in the molecule [5]. This greater mobility allows for more molecules to become excited when the light is absorbed. When these molecules return to their ground state, some of the energy is emitted as fluorescence.\n\n\n\nFig. 3.1 Jablonski Diagram of Fluorescence\n\n\nThe energy that makes up light are called photons. Photons that absorb and excite molecules hold a certain amount of energy that determines their wavelength, or color [6]. When a molecule emits a photon as it returns to ground state, the energy in the photon that is emitted is less than in the photon that was excited. This means that the resulting photon will have a longer wavelength and a different color [6].\nIn order to image fluorescence, the absorbed and emitted photons of light must be controlled based on their wavelength spectrums. The excitation wavelength spectrum and the emission wavelength spectrum can often overlap, allowing the camera to capture photons of both wavelengths. An example of these spectrums is shown in Fig. 3.2, which is the spectrum for a common fluorescenct dye called Fluorescein isothiocyanate (FITC). In order to see the fluorescence of a compound, only the emitted light must be captured by the camera. Implementing an optical filter can help to control what wavelengths are captured. Optical filters allow for wavelengths of a certain range to be the only wavelengths detected by a camera by filtering out other wavelengths.\n\n\n\nFig. 3.2 Exciation and Emission Wavelength Spectrum for FITC\n\n\nFluorescence imaging has a variety of applications including medical imaging, environmental monitoring, and biological research. A common application of fluorescence is to non-invasively analyze biological molecules in vivo. Most IVIS systems use fluorescence for this purpose, and OpenIVIS will also demonstrate this fluorescence capability.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "sections/introduction/index.html#laser-speckle-contrast-imaging",
    "href": "sections/introduction/index.html#laser-speckle-contrast-imaging",
    "title": "3  Introduction",
    "section": "3.3 Laser Speckle Contrast Imaging",
    "text": "3.3 Laser Speckle Contrast Imaging\nLaser Speckle Contrast Imaging (LSCI) is an optical imaging technique used to track movement, such as blood flow, by visualizing blur. When a diffuse object is illuminated with coherent light, it produces scattered light waves which can be visualized as a random interference pattern called a speckle image [7]. Static speckle images have high contrast patterns but when movement is imaged, the fluctuations in intensity can cause the contrast between neighboring speckles to decrease. The speckle contrast, K, can be derived as the standard deviation of pixel intensity over the mean pixel intensity, as shown in Eq. 1. Moving objects, such as blood flowing in a vein, causes the speckle pattern to shift, or decorrelate [8]. When this occurs, the intensity of neighboring speckles will become more similar, decreasing their contrast value.\n\\[\\begin{align}\nK = \\frac{\\sigma }{&lt;I&gt;} \\quad \\text{(Eq.1)}\n\\end{align}\\]\nIn order to compute the contrast of a full speckle image, a small window is applied to the original speckle pattern, typically 5x5 or 7x7 pixels large. This window, often referred to as a “neighborhood” is run over the entire image, computing the speckle contrast K for the intensities at each location before shifting over by 1 pixel at a time. The image is then reconstructed using the respective K values in order to produce a laser speckle contrast image. A speckle image is shown in Fig. 3.3a, and its corresponding LSCI reproduction is shown in Fig. 3.3b [8]. By comparing the contrast patterns between different speckle images over time, the velocity of the movement being imaged can be determined.\n\n\n\nFig. 3.3 An example laser speckle image (a) and it’s LSCI reproduction (b)\n\n\nProperties such as speckle size and autocorrelation can be used to verify camera settings and photo processing for higher quality speckle images. In order to determine the size of the speckles in the speckle pattern, autocorrelation can be applied to the image. Autocorrelation compares the intensity of the speckle pattern at two different points by multiplying values across the entire image. The autocorrelation can also be found by taking the fourier transform of the images intensity distribution [9]. Eq. 2 shows a speckle pattern’s autocorrelation calculation by taking the Fast Fourier Transform of the image’s intensity I(x,y). The transform is then multiplied by its complex conjugate, noted by the asterisk, in the fourier domain to obtain Fcc in Eq. 3. Finally, the inverse fourier transform returns the calculation to the spatial domain, resulting in the autocorrelation FA as shown in Eq. 4. Given the autocorrelation of a speckle image, the size of the speckle in pixels can be determined by finding the width of the autcorrelation’s peak at half of its maximum, often referred to as the full width half max (FWHM). Most speckle images have a speckle size of one to two pixels.\n\\[\\begin{align}\nF_{fft}(f) &= \\text{FFT}\\{I(x,y)\\} \\quad \\text{(Eq.2)} \\\\\nF_{cc}(f) &= F_{fft}(f) \\times F_{fft}^{*}(f) \\quad \\text{(Eq.3)} \\\\\nF_{A}(t) &= \\text{IFFT}\\{F_{cc}(f)\\} \\quad \\text{(Eq.4)}\n\\end{align}\\]\n\n\n\n\n[1] A. Refaat et al., “In vivo fluorescence imaging: Success in preclinical imaging paves the way for clinical applications,” Journal of Nanobiotechnology, vol. 20, no. 1, p. 450, 2022, doi: 10.1186/s12951-022-01648-7.\n\n\n[2] “Vivo imaging system.” https://epicore.ku.edu/vivo-imaging-system.\n\n\n[3] “Perkin elmer IVIS lumina III in vivo imaging system.” https://www.bostonind.com/perkin-elmer-ivis-lumina-iii-in-vivo-imaging-system-av-soldout.\n\n\n[4] “Small animal imaging core lab.” https://medicine.osu.edu/departments/davis-heart-lung-research-institute/core-labs-and-research-centers/small-animal-imaging-core-lab.\n\n\n[5] R. T. Williams and J. W. Bridges, “Fluorescence of solutions: A review,” Journal of clinical pathology, vol. 17, no. 4, p. 371, 1964.\n\n\n[6] G. Saleh, M. Faraji, R. Alizadeh, and A. Dalili, “A new explanation for the color variety of photons,” in MATEC web of conferences, EDP Sciences, 2018, p. 01003.\n\n\n[7] D. A. Boas and A. K. Dunn, “Laser speckle contrast imaging in biomedical optics,” Journal of Biomedical Optics, vol. 15, no. 1, p. 011109, 2010, doi: 10.1117/1.3285504.\n\n\n[8] E. Matthias et al., “Laser speckle contrast imaging: Theoretical and practical limitations,” Journal of Biomedical Optics, vol. 18, no. 6, p. 066018, 2013, doi: 10.1117/1.JBO.18.6.066018.\n\n\n[9] Wikipedia, “Autocorrelation.” https://en.wikipedia.org/wiki/Autocorrelation#Efficient_computation.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "sections/methods/index.html",
    "href": "sections/methods/index.html",
    "title": "4  Methods",
    "section": "",
    "text": "4.1 Physical Construction\nThe OpenIVIS box is made out of laser cut acrylic and 3D printed parts. Black acrylic was cut to form the base, back, and sides of the box. The acrylic pieces have extruding parts along their rims to connect in a jigsaw puzzle configuration. This ensures that no light can leak out of the box and that the box is stable. The front of the box is made from a 3D printed PLA filament and has long notches to allow for the black acrylic door to slide up and down. Fig. 4.1 shows the fully assembled box.\nThe box has two replaceable lids for the different imaging methods.The first lid is designed for laser speckle contrast imaging. The lid is made out of black acrylic with three holes cut into it. One hole holds the camera while the other two holes hold the laser diode configuration described in Section 2.2. Fig. 4.2 shows the assembly used for LSCI.\nThe second lid is designed for fluorescence imaging. It has an upper layer of black acrylic jigsaw pieces. On the underside of the lid is a 3D printed ring to hold an array of Neopixel LEDs. Beneath the LED array is a diffusion plate made of white acrylic to allow for the LEDs to shine through and into the box. A 3D printed camera holder is secured to the white acrylic and has space for a 3D printed optical filter holder to slide in beneath the camera. Fig. 4.3 shows the fully assembled fluorescence top. This configuration can also be used for other imaging methods that implement the Neopixel LED array, as discussed in Section 2.3.4.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods</span>"
    ]
  },
  {
    "objectID": "sections/methods/index.html#physical-construction",
    "href": "sections/methods/index.html#physical-construction",
    "title": "4  Methods",
    "section": "",
    "text": "Fig. 4.1 Image of Assembled Box\n\n\n\n\n\n\n\nFig. 4.3 Image of Fluorescent Lid",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods</span>"
    ]
  },
  {
    "objectID": "sections/methods/index.html#electrical-components-and-software",
    "href": "sections/methods/index.html#electrical-components-and-software",
    "title": "4  Methods",
    "section": "4.2 Electrical Components and Software",
    "text": "4.2 Electrical Components and Software\nThe OpenIVIS system runs primarily off of a Raspberry Pi 4, and other cheap, off-the-shelf electronics. The Raspberry Pi is a series of small single-board computers developed to be an educational tool, which has many interfacing options such as general purpose input/output pins (GPIO) that can connect to sensors. The camera used for all images in this project is an Arducam IMX519 color camera with a 24” flex cable, which is Raspberry Pi compatible and has autofocus features. A desktop and mouse are connected to the USB interfaces of the Raspberry Pi in order to use the system and make any necessary alterations. The system is stored on a 128 GB microSD card with the appropriate Raspberry Pi operating system.\nFor most imaging methods used by the OpenIVIS system, an LED array of Adafruit Neopixel RGB LED modules is used to illuminate subjects under study. In order to connect to the Raspberry Pi, a Raspberry Pi prototyping board is wired along with a logic level converter and terminal block as shown in Fig. 4.4, as well as powered by an external 5V power supply. The LED array is connected to the pulse width modulated (PWM) pin from the Raspberry Pi to provide control. The LED’s are affixed to the 3D printed LED array as described in section 2.1. Unmounted, 25 mm thick long-pass optical glass filters were sourced from Thorlabs in cutoff wavelengths of 515 nm, 570 nm, 665 nm and 695 nm.\n\n\n\nFig. 4.4: Raspberry Pi Prototyping board schematic with the breakout board (a), header pins (b), logic level converter (c), DC audio jack (d), and 3 pin terminal block (e)\n\n\nLSCI and other laser based imaging techniques implement a red ThorLabs 635 nm Collimated Laser Diode Module, along with Thorlabs’ RA90, SM1TC, SM1D12D, GBE05-A, LDS5, TR3, TR6, CPS635R, SM1S10, SM1T1 and AD11F to properly configure the laser beam. The laser configuration as shown in Fig. 4.5a is affixed to the lid of the OpenIVIS box using a 3/8” 1/4-20 bolt, as shown in Fig. 4.5b.\nThe majority of the code used to run the OpenIVIS system is written in the programming language Python, and available in the project’s public GitHub repository [1]. Descriptions of the Python scripts necessary to collect and process data are described in the repository’s “Read Me” file. The list of necessary Python Packages is listed in Appendix 2, and is run on the Raspberry Pi through a virtual environment. The Neopixel LED array and Arducam camera Python libraries are also used and require installation. Additional data processing code was written using Mathworks’ MatLab software.\nA full list of materials, diagrams, and relevant CAD files is available in Appendix 1, Appendix 3 and Appendix 4, respectively.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods</span>"
    ]
  },
  {
    "objectID": "sections/methods/index.html#experiments",
    "href": "sections/methods/index.html#experiments",
    "title": "4  Methods",
    "section": "4.3 Experiments",
    "text": "4.3 Experiments\n\n4.3.1 Verification\nBefore fluorescence and laser speckle contrast imaging, it was necessary to verify that the Arducam camera and the LED lights were working properly. The Neopixel Python library allows for brightness control in two forms. The first is through changing the brightness level of the LED output, which can be set to any value between 0 and 1 arbitrary units. In addition to brightness level, the usage of 4 valued color codes allow for the user to change both the color of the LED output and the brightness of each color. The red, green, blue and white brightness values range from 0 to 255 arbitrary units.\nBrightness level and exposure time verification can be done by changing the exposure time of the camera while keeping the brightness constant and by changing the brightness level of the LEDs while keeping the exposure time constant. The exposure time, or shutter speed, controls how long the camera is exposed to light when taking an image, and it is controlled using picamera2 settings. The brightness level of the LEDs is controlled using the NeoPixel library settings. Images were taken at full brightness and varying exposure times of 0.001, 0.005, 0.01, 0.05, and 0.1 seconds. Images were also taken at exposure times of 0.01 and 0.1 seconds with varying brightness levels from 0 to 1 arbitrary units. These settings for these images were then compared to the intensities of the pixels in the images.\nThe pixel intensities were measured by taking a three by three set of pixels near the center of the image and putting them in an excel spreadsheet. To plot the data a MATLAB script was used to read in the intensity values and average across each set of nine. These averaged values were then averaged across five different trials of varying the brightness level and exposure time. The expected results are positive trends between exposure time and pixel intensity and brightness level and pixel intensity.\nSince the above process will only verify the LEDs based on what the camera is detecting from the LED light, it was also necessary to test the actual LED output using a photodiode. The photodiode outputs wattage values based on the intensity of light detected. Changing both the brightness levels from the NeoPixel settings and the color code values of the red, green, blue, and white LEDs should result in positive trends between brightness value and output wattage. The photodiode was placed inside of the system’s main box compartment with the sensor facing upward. Data was collected for three different sensor locations in the box. For each location, a Python script was used to cycle through the Neopixel brightness levels from 0 to 1, increasing by 0.1 each time to achieve 11 equally distributed brightness levels. For each brightness level, the color code tuples were also cycled from 0 to 255 for each LED color. The color code values increased by 26 a.u. each cycle to achieve 11 equality distributed values. The LED output in nW was saved in a spreadsheet for each setting, resulting in XXX values for each photodiode sensor location. The trends in the white LED output were analyzed for changes in brightness level at a constant color code of 255 a.u., and the changes in color code for a constant brightness level of 1. For each setting, the average wattage and standard deviation was taken across the three trials and inputted into a MatLab script that created graphs of those values across changes in Neopixel setting.\n\n\n4.3.2 Fluorescein Ssothiocyanate\nTo test the fluorescence capabilities of OpenIVIS, ten concentrations of the commonly used fluorescent dye, Fluorescein isothiocyanate (FITC), were diluted in ethanol. FITC emits fluorescence of wavelengths ranging in the green spectrum with a peak around 530 nm [ThermoFisher]. To excite the FITC solutions, blue LEDs were used to illuminate the dye at full brightness. The Neopixel blue spectrum has a peak approximately 450 nm. To prevent the camera from detecting the excitation light, a 515 nm long pass optical filter was placed in front of the camera. The filter blocked out all wavelengths lower than 515 nm, including the blue excitation light. The ten different concentrations of FITC ranged from 10-3 M to 10-12 M. In a 96-well PCR plate, 2 wells of each FITC concentration were placed in a four by five orientation and put into the OpenIVIS box for imaging.\nTo quantify the fluorescence of each FITC concentration, the raw image data from the captured images was converted into Bayer images. The Bayer images have a red, green, green, blue (RGGB) color filter array as shown in Fig. 4.6. In this color filter array there is only one color component in each pixel of the image [2]. The other two color components for the pixel must be interpolated from information gathered from its neighboring pixels [2]. After getting the Bayer images, the first green channel was isolated so that the images have empty and filled values ranging from 0 to 1023 arbitrary units. These images allow for the intensity of the pixels to be extracted and compared across multiple images. Images were taken of the FITC concentrations in a well plate with varying settings. Exposure time and brightness level were changed to see which sets of controls can best represent the trend between FITC concentration and pixel intensity. The final experiment cycled through nine different exposure times, ranging from 1 ms to 10000ms. For each exposure time, five images of the well plate were captured with a brightness level of 1. For mathematical analysis, a python script was used to save the green-channel intensities for each of the filled wells, along with two empty wells for comparison. At each well, the script took the mean intensity and standard deviation of a circle of pixels within a radius of 20 pixels, when given the corresponding center pixel location. These values were saved in an excel spreadsheet and then inputted into Matlab to find the mean and standard deviation of each concentration of FITC across five sets of images. The values were then plotted as intensity over FITC concentration in M.\n\n\n\nFig. 4.6 Bayer Color Filter Array\n\n\n\n\n4.3.3 Laser Speckle Contrast Imaging\nIn order to verify the analysis and LSCI computation of speckle images, a python script was used to create simulated speckle images. A simulated speckle pattern was generated using Python’s numpy library to make an NxN array of randomized, complex intensity values. Typical RGB images have intensities ranging from 0 to 255 arbitrary units. Given the simulated speckle array, a python processing script was used to calculate the phase and amplitude information of the image. Additionally, the script applied a circular, low pass filter in the fourier domain to the speckle pattern to enhance the quality of the image. An autocorrelation calculation was then applied to both the original and filtered speckle patterns using the fourier method described in Section 1.3 in order to quantify the temporal or spatial variations. Next, the speckle size was determined by finding the location in which the autocorrelation reaches the maximum of its peak on either side. The simulation was then run through a LSCI loop to calculate the K values as described in Section 1.3.\nTo take real-world speckle images for analysis, the modified box lid described in Section 2.3.2 was used. The laser module in Fig. 4.7a was affixed to the lid of the OpenIVIS box using a 3/8” 1/4-20 bolt along with the Arducam camera, as shown in Fig. 4.7b. In order to mimic movement that might be seen in a biological system, such as a vein with blood flow, a clear plastic tube was run through the center of the box. Diffuse liquid was pushed through the tube at varying flow rates by a kdScientific Syringe Pump and a 20 mL syringe with a Luer Lock. The area of the tube under study was placed directly under the Raspberry Pi camera and illuminated with the laser module. Images were taken using the corresponding python script and saved as .bmp files, and Bayer images as .npy arrays. Additionally, the green channel of the Bayer image were saved using a mask, as discussed in Section 2.3.2. The resulting images were processed using an additional python program to calculate the speckle size, intensity histogram and LSCI pattern.\n\n\n4.3.4 Additional Capabilities\nIn addition to fluorescence imaging and LSCI, the OpenIVIS system was verified for time lapse imaging. As discussed in the paper by Branning et. al [3], the IVIS system can be used to image growth or changes in an organism or process over time. To verify this capability, 11 Tobacco Hornworms in individual, clear tubes were placed into the main section of the imaging box. The box was kept in a room set to 73oC to maintain healthy temperatures. The Neopixel LEDs were set to their full brightness in order to promote proper lighting conditions for growth. A python script was run through the Raspberry Pi that captures time lapsed images over a 10 day period. Images were set to be taken every five hours during that period. The images were then saved in a folder to be analyzed for hornworm growth.\nThe OpenIVIS system’s versatile nature also provides opportunities for further scientific experiments. One possibility for the system’s applications is the imaging of a degrading plant’s Anthocyanin response. When plants decompose, they produce a fluorescent pigment called Anthocyanin. The Anthocyanin response can be visualized by taking the logarithm of the pixel intensities when excited by a red wavelength of light, over the intensity excited by a green wavelength of light, as shown in Eq. 5. In the OpenIVIS box, a lettuce leaf was placed in the main compartment. Using the Neopixel LED array, images were taken with red and green excitations of 653 nm and 520 nm respectively. Additionally, a long pass optical filter with a cutoff wavelength of 665 nm was placed below the camera in the system’s filter holder to remove wavelengths below the red value. Images were taken three days apart for decomposition analysis. The images were then processed in python by applying Eq. 5 [4] for each pixel location in the image.\n\\[\\begin{align}\nA_{R} = log(\\frac{I_{635nm}-I_{520nm}}{I_{635nm}+I_{520nm}}) \\quad \\text{(Eq.5)}\n\\end{align}\\]\n\n\n\n\n[1] H. Biophotonics, “openIVIS.” 2024. Available: https://github.com/hmcbiophotonics/openIVIS/tree/main\n\n\n[2] S.-Y. Lee and A. Ortega, “A novel approach of image compression in digital cameras with a bayer color filter array,” in Proceedings 2001 international conference on image processing (cat. No. 01CH37205), IEEE, 2001, pp. 482–485.\n\n\n[3] J. H. Lee, M. H. Park, S. Y. Kim, D. H. Lim, S. J. Lee, and J. W. Choi, “Detection of aflatoxin B1 in rice using fluorescent nanoparticles with a fast response time,” PLOS ONE, vol. 19, no. 2, p. e0299875, 2024, doi: 10.1371/journal.pone.0299875.\n\n\n[4] X. Zhang et al., “Genome-wide identification and characterization of the mitogen-activated protein kinase (MAPK) gene family in the dendrobium candidum,” Frontiers in Plant Science, vol. 14, p. 1155722, 2023, doi: 10.3389/fpls.2023.1155722.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods</span>"
    ]
  },
  {
    "objectID": "sections/results/results.html",
    "href": "sections/results/results.html",
    "title": "5  Results",
    "section": "",
    "text": "5.1 System Verification and Setup",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "sections/results/results.html#system-verification-and-setup",
    "href": "sections/results/results.html#system-verification-and-setup",
    "title": "5  Results",
    "section": "",
    "text": "5.1.1 Changing Exposure Time\nIn Fig. 5.1, there is a positive, non-linear relationship between exposure time and pixel intensity. Initially there is a large increase in pixel intensity as exposure time increases and this is most likely because as exposure time increases, more photons will be detected by the pixels in the camera. As exposure time continues to increase, the increase in pixel intensity starts to decrease. This is most likely because the pixels can only hold a certain amount of photons and when a pixel has stored its maximum amount of photons, it has reached its saturation point. As more photons are being detected by the pixels from the increasing exposure times, the pixels are getting closer to their saturation point [1]. This plot also has a small error across the different trials, suggesting that the exposure times are precise.\n\nRead and Plot Exposure Values\n\n\nShow code from exposure_analysis.py\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import curve_fit\n\ndata1 = pd.read_excel(\"Data/exposure/lastExposure1.xlsx\", sheet_name=\"Sheet2\")\ndata2 = pd.read_excel(\"Data/exposure/lastExposure2.xlsx\", sheet_name=\"Sheet2\")\ndata3 = pd.read_excel(\"Data/exposure/lastExposure3.xlsx\", sheet_name=\"Sheet2\")\ndata4 = pd.read_excel(\"Data/exposure/lastExposure4.xlsx\", sheet_name=\"Sheet2\")\ndata5 = pd.read_excel(\"Data/exposure/lastExposure5.xlsx\", sheet_name=\"Sheet2\")\n\n# For Exposure Times\ndata1_subsets = [data1.iloc[i:i+8].values.flatten() for i in range(0, 45, 9)]\ndata2_subsets = [data2.iloc[i:i+8].values.flatten() for i in range(0, 45, 9)]\ndata3_subsets = [data3.iloc[i:i+8].values.flatten() for i in range(0, 45, 9)]\ndata4_subsets = [data4.iloc[i:i+8].values.flatten() for i in range(0, 45, 9)]\ndata5_subsets = [data5.iloc[i:i+8].values.flatten() for i in range(0, 45, 9)]\n\n# Calculate means and std for each subset\nm_data1 = np.array([np.mean(subset) for subset in data1_subsets])\nm_data2 = np.array([np.mean(subset) for subset in data2_subsets])\nm_data3 = np.array([np.mean(subset) for subset in data3_subsets])\nm_data4 = np.array([np.mean(subset) for subset in data4_subsets])\nm_data5 = np.array([np.mean(subset) for subset in data5_subsets])\n\ns_data1 = np.array([np.std(subset) for subset in data1_subsets])\ns_data2 = np.array([np.std(subset) for subset in data2_subsets])\ns_data3 = np.array([np.std(subset) for subset in data3_subsets])\ns_data4 = np.array([np.std(subset) for subset in data4_subsets])\ns_data5 = np.array([np.std(subset) for subset in data5_subsets])\n# \n# Combine means and std of each numbered data\nmeans = np.mean([m_data1, m_data2, m_data3, m_data4, m_data5], axis=0)\n\nstds = np.std([s_data1, s_data2, s_data3, s_data4, s_data5], axis=0)\n\nexp = [0.001, 0.005, 0.01, 0.05, 0.1]\n\nplt.figure()\nplt.errorbar(exp, means, yerr=stds, fmt='o', color='red', linewidth=2, markersize=6, label='Mean')\nplt.title('Brightness Level = 0.7')\nplt.suptitle('Pixel Intensity vs. Exposure Time')\nplt.ylim([0, 1100])\nplt.xlabel('Exposure Time [s]')\nplt.ylabel('Pixel Intensity [a.u.]')\n# Polynomial Fit\ncoeffs = np.polyfit(exp, means, 4)\ny_fit = np.polyval(coeffs, exp)\nplt.plot(exp, y_fit, 'r', linewidth=2)\n\nplt.savefig('images/exposure.png')\nplt.close()\n\n\n\n\n\n\n\n\nFigure 5.1: The pixel intensity versus exposure time.\n\n\n\n\n\n\n5.1.2 Changing Brightness Level\nIn both of the plots shown in Fig. 5.2, there is a positive trend between brightness level and pixel intensity. When the exposure time was set to 0.01 seconds (Fig. 5.2a), the pixel intensity increases linearly and then flattens out around 1023 arbitrary units. This number matches with the intensity when exposure time is 0.01 seconds in Fig. 5.1 above, suggesting that the exposure time has a significant impact on the resulting plot of brightness level vs pixel intensity. When the exposure time is increased to 0.1 seconds in Fig. 5.2b, the linear portion of the graph seems to shift to higher brightness levels and starts to flatten out around 1000 arbitrary units. This intensity value also agrees with the intensity value of an exposure time of 0.1 seconds in Fig. 5.1 above. The trend that this data supports is that the camera will most accurately capture LED brightness when the brightness level is low and the exposure time is quick and when the brightness level is high and the exposure time is slow. There is also a very small error across the different trials, suggesting that the camera is capturing the LED brightness precisely.\n\nRead and Plot Brightness Values\n\n\nShow code from brightness_analysis.py\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Read the data from Sheet 2\ndata1 = pd.read_excel(\"Data/brightness/lastBrightness1.xlsx\", sheet_name=\"Sheet2\")\ndata2 = pd.read_excel(\"Data/brightness/lastBrightness2.xlsx\", sheet_name=\"Sheet2\")\ndata3 = pd.read_excel(\"Data/brightness/lastBrightness3.xlsx\", sheet_name=\"Sheet2\")\ndata4 = pd.read_excel(\"Data/brightness/lastBrightness4.xlsx\", sheet_name=\"Sheet2\")\ndata5 = pd.read_excel(\"Data/brightness/lastBrightness5.xlsx\", sheet_name=\"Sheet2\")\n\n# For Brightness Levels\ndata1_subsets = [data1.iloc[i:i+9].values.flatten() for i in range(0, 99, 9)]\ndata2_subsets = [data2.iloc[i:i+9].values.flatten() for i in range(0, 99, 9)]\ndata3_subsets = [data3.iloc[i:i+9].values.flatten() for i in range(0, 99, 9)]\ndata4_subsets = [data4.iloc[i:i+9].values.flatten() for i in range(0, 99, 9)]\ndata5_subsets = [data5.iloc[i:i+9].values.flatten() for i in range(0, 99, 9)]\n\n# Calculate means and std for each subset\nm_data1 = np.array([np.mean(subset) for subset in data1_subsets])\nm_data2 = np.array([np.mean(subset) for subset in data2_subsets])\nm_data3 = np.array([np.mean(subset) for subset in data3_subsets])\nm_data4 = np.array([np.mean(subset) for subset in data4_subsets])\nm_data5 = np.array([np.mean(subset) for subset in data5_subsets])\n\ns_data1 = np.array([np.std(subset) for subset in data1_subsets])\ns_data2 = np.array([np.std(subset) for subset in data2_subsets])\ns_data3 = np.array([np.std(subset) for subset in data3_subsets])\ns_data4 = np.array([np.std(subset) for subset in data4_subsets])\ns_data5 = np.array([np.std(subset) for subset in data5_subsets])\n\n# Combine means and std of each numbered data\nmeans = np.mean([m_data1, m_data2, m_data3, m_data4, m_data5], axis=0)\n\nstds = np.std([s_data1, s_data2, s_data3, s_data4, s_data5], axis=0)\n\nbri = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n\n# Plotting\nplt.figure()\nplt.errorbar(bri, means, yerr=stds, fmt='o', color='blue', linewidth=2, markersize=6, label='Mean')\nplt.title('Exposure Time = 0.01 s')\nplt.suptitle('Pixel Intensity vs. Brightness Level')\nplt.ylim([0, 1100])\nplt.xlabel('Brightness Level [a.u.]')\nplt.ylabel('Pixel Intensity [a.u.]')\n# Polynomial Fit\ncoeffs = np.polyfit(bri, means, 4)\ny_fit = np.polyval(coeffs, bri)\nplt.plot(bri, y_fit, 'b', linewidth=2)\n\nplt.savefig('images/brightness.png')\nplt.close()\n\n\n# Read the data from Sheet 2\ndata1 = pd.read_excel(\"Data/brightness/B1.xlsx\", sheet_name=\"Sheet2\")\ndata2 = pd.read_excel(\"Data/brightness/B2.xlsx\", sheet_name=\"Sheet2\")\ndata3 = pd.read_excel(\"Data/brightness/B3.xlsx\", sheet_name=\"Sheet2\")\ndata4 = pd.read_excel(\"Data/brightness/B4.xlsx\", sheet_name=\"Sheet2\")\ndata5 = pd.read_excel(\"Data/brightness/B5.xlsx\", sheet_name=\"Sheet2\")\n\n# For Brightness Levels\ndata1_subsets = [data1.iloc[i:i+9].values.flatten() for i in range(0, 99, 9)]\ndata2_subsets = [data2.iloc[i:i+9].values.flatten() for i in range(0, 99, 9)]\ndata3_subsets = [data3.iloc[i:i+9].values.flatten() for i in range(0, 99, 9)]\ndata4_subsets = [data4.iloc[i:i+9].values.flatten() for i in range(0, 99, 9)]\ndata5_subsets = [data5.iloc[i:i+9].values.flatten() for i in range(0, 99, 9)]\n\n# Calculate means and std for each subset\nm_data1 = np.array([np.mean(subset) for subset in data1_subsets])\nm_data2 = np.array([np.mean(subset) for subset in data2_subsets])\nm_data3 = np.array([np.mean(subset) for subset in data3_subsets])\nm_data4 = np.array([np.mean(subset) for subset in data4_subsets])\nm_data5 = np.array([np.mean(subset) for subset in data5_subsets])\n\ns_data1 = np.array([np.std(subset) for subset in data1_subsets])\ns_data2 = np.array([np.std(subset) for subset in data2_subsets])\ns_data3 = np.array([np.std(subset) for subset in data3_subsets])\ns_data4 = np.array([np.std(subset) for subset in data4_subsets])\ns_data5 = np.array([np.std(subset) for subset in data5_subsets])\n\n# Combine means and std of each numbered data\nmeans = np.mean([m_data1, m_data2, m_data3, m_data4, m_data5], axis=0)\n\nstds = np.std([s_data1, s_data2, s_data3, s_data4, s_data5], axis=0)\n\nbri = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n\n# Plotting\nplt.figure()\nplt.errorbar(bri, means, yerr=stds, fmt='o', color='blue', linewidth=2, markersize=6, label='Mean')\nplt.title('Exposure Time = 0.01 s')\nplt.suptitle('Pixel Intensity vs. Brightness Level')\nplt.ylim([0, 1100])\nplt.xlabel('Brightness Level [a.u.]')\nplt.ylabel('Pixel Intensity [a.u.]')\n# Polynomial Fit\ncoeffs = np.polyfit(bri, means, 4)\ny_fit = np.polyval(coeffs, bri)\nplt.plot(bri, y_fit, 'b', linewidth=2)\n\nplt.savefig('images/brightness2.png')\nplt.close()\n\n\n\n\n\nFig. 5.2a The pixel intensity versus brightness level for an exposure time of 0.01s\n\n\n\n\n\nFig. 5.2b The pixel intensity versus brightness level for an exposure time of 0.1.\n\n\n\n\n\n5.1.3 Measuring From a Photodiode\nBoth Fig. 5.3a and Fig. 5.3b depict a positive, non-linear relationship between brightness and wattage from the photodiode. Fig. 5.3a shows increasing brightness level from the NeoPixel controls while Figure 5.3b shows increasing tuple value, or color code value. The plots are extremely similar in both shape and in error. The error across the different trials are a lot larger than in Figuress 5.1 and 5.2. This is because the photodiode is measuring the actual LED output rather than what the camera is capturing the brightness to be. The LEDs being used are off the shelf and relatively cheap, so it was expected that they would be less precise than more expensive LED options.\n\nRead and Plot Photodiode Values\n\n\nShow code from FITC_analysis.py\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Data\nlevel = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\nmeanLevel = [0.566, 194.9, 373.5, 552, 687, 820, 964.3333333, 1063.333333, 1152, 1222, 1287.333333]\nstdLevel = [0.305, 20.22374842, 37.05738793, 56.15158057, 57.10516614, 67.44627492, 97.42860634, 105.6519443, 102.8931485, 101.7693471, 93.60199428]\n\ntuple_vals = [0, 25, 51, 76, 102, 127, 153, 178, 204, 229, 255]\nmeanTuple = [0.566, 194.7, 384, 552, 710, 843, 961.3333333, 1061, 1148.333333, 1221, 1287.333333]\nstdTuple = [0.305, 19.43167517, 38.19685851, 53.3291665, 67.29041537, 76.92203845, 83.912653, 89.59910714, 92.1430048, 93.25770746, 93.60199428]\n\n# Plot for tuple values\nplt.figure()\nplt.errorbar(tuple_vals, meanTuple, yerr=stdTuple, fmt='ob', linewidth=2, markersize=6, markerfacecolor='b', label='Mean Tuple')\n\n# Polynomial fit for tuple values\na1 = np.polyfit(tuple_vals, meanTuple, 2)\ny1 = np.polyval(a1, tuple_vals)\nplt.plot(tuple_vals, y1, 'b', linewidth=2)\npStr1 = 'y = {:.2f}x^2 + {:.2f}x + {:.2f}'.format(a1[0], a1[1], a1[2])\n# Calculate the residuals\nresiduals1 = meanTuple - y1\n\n# Calculate the total sum of squares (SStot)\nSStot1 = np.sum((meanTuple - np.mean(meanTuple))**2)\n\n# Calculate the sum of squares of residuals (SSres)\nSSres1 = np.sum(residuals1**2)\n\n# Calculate R-squared\nR21 = 1 - (SSres1 / SStot1)\n\n# Display the results\npStr1R = f'R² = {R21:.4f}'\n\nplt.title('LED Output vs. Tuple Value for Brightness Level = 1')\nplt.xlabel('Tuple Value [a.u.]')\nplt.ylabel('LED Output [nW]')\nplt.xlim([0, 260])\nplt.ylim([0, 1400])\nxPos = max(tuple_vals) - 150\nyPos = min(meanTuple) + 200\nplt.text(xPos, yPos, pStr1, fontsize=12, color='b')\nplt.text(xPos, yPos-100, pStr1, fontsize=12, color='b')\n\nplt.legend()\nplt.savefig('images/photodiodeTuple.png')\nplt.close()\n\n# Plot for brightness levels\nplt.figure()\nplt.errorbar(level, meanLevel, yerr=stdLevel, fmt='+r', linewidth=2, markersize=6, markerfacecolor='r', label='Mean Level')\n\n# Polynomial fit for brightness levels\na2 = np.polyfit(level, meanLevel, 2)\ny2 = np.polyval(a2, level)\nplt.plot(level, y2, 'r', linewidth=2)\npStr2 = 'y = {:.2f}x^2 + {:.2f}x + {:.2f}'.format(a2[0], a2[1], a2[2])\n# Calculate the residuals\nresiduals2 = meanLevel - y2\n# Calculate the total sum of squares (SStot)\nSStot2 = np.sum((meanLevel - np.mean(meanLevel))**2)\n# Calculate the sum of squares of residuals (SSres)\nSSres2 = np.sum(residuals2**2)\n# Calculate R-squared\nR22 = 1 - (SSres2 / SStot2)\n# Display the results\npStr2R = f'R² = {R22:.4f}'\n\nplt.title('LED Output vs. Brightness Level for Brightness Tuple = (0,0,0,255)')\nplt.xlabel('Brightness Level [a.u.]')\nplt.ylabel('LED Output [nW]')\nplt.xlim([0, 1.1])\nplt.ylim([0, 1400])\nxPos = max(level) - 0.6\nyPos = min(meanLevel) + 200\nplt.text(xPos, yPos, pStr2, fontsize=12, color='r')\nplt.text(xPos, yPos-100, pStr2, fontsize=12, color='r')\nplt.legend()\n\nplt.savefig('images/photodiodeLevel.png')\nplt.close()\n\n\n\n\n\nFig. 5.3a The photodiode pixel intensity versus color code for a brightness level of 1.\n\n\n\n\n\nFig. 5.3b The photodiode pixel intensity versus brightness level for a color code of (0,0,0,255).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "sections/results/results.html#fluorescence-imaging",
    "href": "sections/results/results.html#fluorescence-imaging",
    "title": "5  Results",
    "section": "5.2 Flourescence Imaging",
    "text": "5.2 Flourescence Imaging\nFig. 5.5 shows the normalized pixel intensities of all ten concentrations of FITC for eight different exposure times. As exposure time and concentration increases, the pixel intensity also increases. The 100 milliseconds, or 0.1 seconds, exposure time best represents the expected relationship between concentration and pixel intensity (green curve). As seen in Fig. 5.6, the lower concentrations of FITC are a lot less fluorescent than the higher concentrations. The green curve in Fig. 5.5 shows a large increase in pixel intensity in the higher concentrations, with it flattening out at the maximum value of 1 in the normalized plot. This maximum value of 1 corresponds to 1023 arbitrary units. The slower exposure times (purple and blue curves) also show the trend to an extent. These larger exposure times mean that the images captured by the camera are super bright, so most of the concentrations have large intensity values. The faster exposure times have the opposite effect. The images captured by the camera are super dark, and the pixel intensity values are low. The intensity values for each concentration represent how fluorescent each concentration is. Based on this data, the higher concentrations of FITC are more fluorescent than the lower concentrations.\n\nRead FITC Data and Extract Values\n\n\nShow code from FITC_analysis.py\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Read the data from the Excel files\ndata1 = pd.read_excel(\"Data/FITC/pixel_circle1.xlsx\")\ndata2 = pd.read_excel(\"Data/FITC/pixel_circle2.xlsx\")\ndata3 = pd.read_excel(\"Data/FITC/pixel_circle3.xlsx\")\ndata4 = pd.read_excel(\"Data/FITC/pixel_circle4.xlsx\")\ndata5 = pd.read_excel(\"Data/FITC/pixel_circle5.xlsx\")\n\ndata1m = data1.iloc[:, 2].values\ndata2m = data2.iloc[:, 2].values\ndata3m = data3.iloc[:, 2].values\ndata4m = data4.iloc[:, 2].values\ndata5m = data5.iloc[:, 2].values\n\ndata1s = data1.iloc[:, 3].values\ndata2s = data2.iloc[:, 3].values\ndata3s = data3.iloc[:, 3].values\ndata4s = data4.iloc[:, 3].values\ndata5s = data5.iloc[:, 3].values\n\n# Extract the subsets For FITC\nm_con_00001 = np.array([data1m[:10], data2m[:10], data3m[:10], data4m[:10], data5m[:10]])\nm_con_00005 = np.array([data1m[10:21], data2m[10:21], data3m[10:21], data4m[10:21], data5m[10:21]])\nm_con_00010 = np.array([data1m[21:32], data2m[21:32], data3m[21:32], data4m[21:32], data5m[21:32]])\nm_con_00050 = np.array([data1m[32:43], data2m[32:43], data3m[32:43], data4m[32:43], data5m[32:43]])\nm_con_00100 = np.array([data1m[43:54], data2m[43:54], data3m[43:54], data4m[43:54], data5m[43:54]])\nm_con_00500 = np.array([data1m[54:65], data2m[54:65], data3m[54:65], data4m[54:65], data5m[54:65]])\nm_con_01000 = np.array([data1m[65:76], data2m[65:76], data3m[65:76], data4m[65:76], data5m[65:76]])\nm_con_10000 = np.array([data1m[76:87], data2m[76:87], data3m[76:87], data4m[76:87], data5m[76:87]])\nm_con_05000 = np.array([data1m[87:98], data2m[87:98], data3m[87:98], data4m[87:98], data5m[87:98]])\n\nm_con_00001 = m_con_00001.astype(float)\nm_con_00005 = m_con_00005.astype(float)\nm_con_00010 = m_con_00010.astype(float)\nm_con_00050 = m_con_00050.astype(float)\nm_con_00100 = m_con_00100.astype(float)\nm_con_00500 = m_con_00500.astype(float)\nm_con_01000 = m_con_01000.astype(float)\nm_con_10000 = m_con_10000.astype(float)\nm_con_05000 = m_con_05000.astype(float)\n\n# Calculate standard deviations\nstd_con_00001 = np.std(m_con_00001, axis=0)\nstd_con_00005 = np.std(m_con_00005, axis=0)\nstd_con_00010 = np.std(m_con_00010, axis=0)\nstd_con_00050 = np.std(m_con_00050, axis=0)\nstd_con_00100 = np.std(m_con_00100, axis=0)\nstd_con_00500 = np.std(m_con_00500, axis=0)\nstd_con_01000 = np.std(m_con_01000, axis=0)\nstd_con_05000 = np.std(m_con_05000, axis=0)\nstd_con_10000 = np.std(m_con_10000, axis=0)\n\n# Calculate means\nm_con_00001 = np.mean(m_con_00001, axis=0)\nm_con_00005 = np.mean(m_con_00005, axis=0)\nm_con_00010 = np.mean(m_con_00010, axis=0)\nm_con_00050 = np.mean(m_con_00050, axis=0)\nm_con_00100 = np.mean(m_con_00100, axis=0)\nm_con_00500 = np.mean(m_con_00500, axis=0)\nm_con_01000 = np.mean(m_con_01000, axis=0)\nm_con_05000 = np.mean(m_con_05000, axis=0)\nm_con_10000 = np.mean(m_con_10000, axis=0)\n\n# Normalize data\nstd_con_00001 /= 1023\nstd_con_00005 /= 1023\nstd_con_00010 /= 1023\nstd_con_00050 /= 1023\nstd_con_00100 /= 1023\nstd_con_00500 /= 1023\nstd_con_01000 /= 1023\n\nm_con_00001 /= 1023\nm_con_00005 /= 1023\nm_con_00010 /= 1023\nm_con_00050 /= 1023\nm_con_00100 /= 1023\nm_con_00500 /= 1023\nm_con_01000 /= 1023\n\n\n\n\nPlot FITC Data\n\n\nShow code from FITC_analysis.py\n# Plotting\nconcentration = [10**-3, 10**-4, 10**-5, 10**-6, 10**-7, 10**-8, 10**-9, 10**-10, 10**-11, 10**-12, 10**-14]\nconc = [-3, -4, -5, -6, -7, -8, -9, -10, -11, -12]\n\nplt.plot(conc, m_con_00001[:10], '-o', color='blue', linewidth=1, markersize=6, markerfacecolor='blue', label='1ms')\nplt.plot(conc, m_con_00005[:10], '-o', color='magenta', linewidth=1, markersize=6, markerfacecolor='magenta', label='5ms')\nplt.plot(conc, m_con_00010[:10], '-o', color='#FFA500', linewidth=1, markersize=6, markerfacecolor='#FFA500', label='10ms')\nplt.plot(conc, m_con_00050[:10], '-o', color='red', linewidth=1, markersize=6, markerfacecolor='red', label='50ms')\nplt.plot(conc, m_con_00100[:10], '-o', color='green', linewidth=1, markersize=6, markerfacecolor='green', label='100ms')\nplt.plot(conc, m_con_00500[:10], '-o', color='cyan', linewidth=1, markersize=6, markerfacecolor='cyan', label='500ms')\nplt.plot(conc, m_con_01000[:10], '-o', color='#7E2F8E', linewidth=1, markersize=6, markerfacecolor='#7E2F8E', label='1000ms')\n\nplt.errorbar(conc, m_con_00001[:10], yerr=std_con_00001[:10], fmt='o', color='blue', linewidth=2, markerfacecolor='none')\nplt.errorbar(conc, m_con_00005[:10], yerr=std_con_00005[:10], fmt='o', color='magenta', linewidth=2, markerfacecolor='none')\nplt.errorbar(conc, m_con_00010[:10], yerr=std_con_00010[:10], fmt='o', color='#FFA500', linewidth=2, markerfacecolor='none')\nplt.errorbar(conc, m_con_00050[:10], yerr=std_con_00050[:10], fmt='o', color='red', linewidth=2, markerfacecolor='none')\nplt.errorbar(conc, m_con_00100[:10], yerr=std_con_00100[:10], fmt='o', color='green', linewidth=2, markerfacecolor='none')\nplt.errorbar(conc, m_con_00500[:10], yerr=std_con_00500[:10], fmt='o', color='cyan', linewidth=2, markerfacecolor='none')\nplt.errorbar(conc, m_con_01000[:10], yerr=std_con_01000[:10], fmt='o', color='#7E2F8E', linewidth=2, markerfacecolor='none')\n\nplt.title('Pixel Intensity vs. Concentration')\nplt.xlabel('Log[FITC Concentration M]')\nplt.ylabel('Pixel Intensity')\nplt.legend(loc='upper right')\nplt.savefig('images/FITC.png')\nplt.close()\n\n\n\n\n\nFig. 5.5 The pixel intensity versus FITC concentration for varying exposure times.\n\n\n\n\n\nFig. 5.6 Fluorescent image of FITC concentrations in a well plate",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "sections/results/results.html#laser-speckle-contrast-imaging",
    "href": "sections/results/results.html#laser-speckle-contrast-imaging",
    "title": "5  Results",
    "section": "5.3 Laser Speckle Contrast Imaging",
    "text": "5.3 Laser Speckle Contrast Imaging\n\n5.3.1 Simulation\nUsing the process described in Section 3.3.3, analysis on simulated speckle images and the effect of filtering was run. Fig. 5.7 depicts the simulated results for a filter with cutoff frequency of N/4, where N denotes the size of the speckle image in pixels, while Figures 5.8 and 5.9 show the results for cutoff frequency of N/8 and N/16, respectively.\n\nCreate a Simulated Speckle Image\n\n\nShow code from speckleSimulation.py\n# Import the necessary Python packages\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nimport os\nfrom PIL import Image\n\ndef ft2(im):\n    \"\"\"\n    Takes the fourier transform\n    \"\"\"\n    return np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(im)))\n\n# Function for Inverse Fourier Transform\ndef ift2(im):\n    \"\"\"\n    Takes the inverse fourier transform\n    \"\"\"\n    return np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(im)))\n\n# Generate a speckle pattern\nN = 255  # Size of the speckle pattern\na = np.random.randn(N, N) + 1j * np.random.randn(N, N)\n\n\n\n\nCreate a filter and Apply it to the Speckle Image\n\n\nShow code from speckleSimulation.py\n# Compute amplitude, phase and intensity of the original speckle pattern\namplitude = np.abs(a)\nphase = np.angle(a)\nintensity = amplitude **2\n\n# Fourier transform of the speckle field\nA = ft2(a)\n# Create a circular low-pass filter\nx = np.linspace(-N/2, N/2, N)\ny = np.linspace(-N/2, N/2, N)\nX, Y = np.meshgrid(x, y)\nradius = np.sqrt(X**2 + Y**2)\ncutoff = N/4  # Adjust the cutoff frequency to control the speckle size\nfilter = radius &lt; cutoff\n\n# Apply the low-pass filter\nA_filtered = A * filter\n\n# Inverse Fourier transform back to the spatial domain\na_filtered = ift2(A_filtered)\n\n\n# Compute the amplitude, phase and intensity of the filtered speckle pattern\namplitude_filtered = np.abs(a_filtered)\nphase_filtered = np.angle(a_filtered)\nintensity_filtered = amplitude_filtered **2\n\n\n\n\nCompute the Autocorrelation and Speckle Size\n\n\nShow code from speckleSimulation.py\n# Compute autocorrelation of the original and filtered speckle patterns\nautocorrelation_original = ift2(ft2(intensity) * np.conj(ft2(intensity)))\nautocorrelation_filtered = ift2(ft2(intensity_filtered) * np.conj(ft2(intensity_filtered)))\n\nautocorrelation_original = np.abs(autocorrelation_original)  # Take the magnitude\nautocorrelation_filtered = np.abs(autocorrelation_filtered)  # Take the magnitude\n\n# Normalize the autocorrelations for better visualization\nautocorrelation_original /= autocorrelation_original.max()\nautocorrelation_filtered /= autocorrelation_filtered.max()\n\n# The code below is for finding the speckle sizes of the images\n\n# Get the slice of the autocorrelation in line with the peak\ncentral_slice_original = autocorrelation_original[N//2, :]\ncentral_slice_filtered = autocorrelation_filtered[N//2, :]\n\n# Find the halfway point between the maximum and the steady state\nhalf_max_original = ((central_slice_original.max() - central_slice_original.min()) / 2 ) + central_slice_original.min()\nhalf_max_filtered = ((central_slice_filtered.max() - central_slice_filtered.min()) / 2 ) + central_slice_filtered.min()\n\n# Find all of the pixels above the halfway point\nindices_original = np.where(central_slice_original &gt;= half_max_original)[0]\nindices_filtered = np.where(central_slice_filtered &gt;= half_max_filtered)[0]\n\n# Find the width of the peak at the halfway point\nif indices_original.size == 1:\n    speckle_size_original = 1\nelse:\n    speckle_size_original = indices_original[-1] - indices_original[0]\n    \nif indices_filtered.size == 1:\n    speckle_size_filtered = 1\nelse:\n    speckle_size_filtered = indices_filtered[-1] - indices_filtered[0]\n\n# Print the speckle sizes\nprint(f\"Original speckle size (width at half maximum): {speckle_size_original} pixels\")\nprint(f\"Filtered speckle size (width at half maximum): {speckle_size_filtered} pixels\")\n\n\n# Rayleigh Distribution for the amplitude histograms\nflat = np.abs(amplitude.flatten())\nflat_fil = np.abs(amplitude_filtered.flatten())\n\nsigma = np.sqrt(np.mean(flat**2) / 2)\nsigma_fil = np.sqrt(np.mean(flat_fil**2) / 2)\n\nx = np.linspace(0, np.max(flat), 255)\nx_fil = np.linspace(0, np.max(flat_fil), 255)\n\nray = (x / sigma**2) * np.exp(-x**2 / (2 * sigma**2))\nray_fil = (x_fil / sigma_fil**2) * np.exp(-x_fil**2 / (2 * sigma_fil**2))\n\n\n# Zoom into the autocorrelations\nzoom = 100\ncenter = np.array(autocorrelation_original.shape) // 2\ncenter_fil = np.array(autocorrelation_filtered.shape) // 2\n\nzoomRegion = (slice(center[0]-zoom, center[0]+zoom), slice(center[1]-zoom, center[1]+zoom))\nzoomRegion_fil = (slice(center_fil[0]-zoom, center_fil[0]+zoom), slice(center_fil[1]-zoom, center_fil[1]+zoom))\n\nautoZoom = autocorrelation_original[zoomRegion]\nautoZoom_fil = autocorrelation_filtered[zoomRegion_fil]\n\n\nOriginal speckle size (width at half maximum): 253 pixels\nFiltered speckle size (width at half maximum): 1 pixels\n\n\n\n\nCreate plots\n\n\nShow code from speckleSimulation.py\ndef add_colorbar(him, ax, cbar_title=\"\"):\n    \"\"\"\n    This function adds a nicely-formatted colorbar\n    \"\"\"\n    divider = make_axes_locatable(ax)\n    cax = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n    cbar = plt.colorbar(him, cax=cax)\n    cbar.set_label(cbar_title, rotation=270, labelpad=15)\n\n# Fiure fo comparing the autocorrelations of the original and filtered speckle patterns\nfig, a = plt.subplots(ncols=2, nrows=3, figsize=(10,20))\n\n# Plot the original amplitude\nim_amp = a[0, 0].imshow(amplitude, cmap='gray')\na[0, 0].set_title('Original Speckle Field Amplitude')\nadd_colorbar(im_amp, a[0, 0], \"Amplitude [a.u.]\")\n\n# Plot the filtered amplitude\nim_amp_filtered = a[0, 1].imshow(amplitude_filtered, cmap='gray')\na[0, 1].set_title('Filtered Speckle Field Amplitude')\nadd_colorbar(im_amp_filtered, a[0, 1], \"Amplitude [a.u.]\")\n\n# Plot the autocorrelation of the original speckle pattern\nim_autoZoom = a[1, 0].imshow(autoZoom, cmap='gray')\na[1, 0].set_title('Autocorrelation of Original Speckle Pattern')\nadd_colorbar(im_autoZoom, a[1, 0], \"Intensity [a.u.]\")\n\n# Plot the autocorrelation of the filtered speckle pattern\nim_autoZoom_fil = a[1, 1].imshow(autoZoom_fil, cmap='gray')\na[1, 1].set_title('Autocorrelation of Filtered Speckle Pattern')\nadd_colorbar(im_autoZoom_fil, a[1, 1], \"Intensity [a.u.]\")\n\n# Plot the central slice of the original autocorrelation (zoomed)\na[2,0].plot(central_slice_original, color='black')\na[2,0].axhline(y=half_max_original, color='red', linestyle='--')\na[2,0].set_title('Central Slice of Original Autocorrelation')\na[2,0].set_xlabel('Pixel')\na[2,0].set_ylabel('Intensity [a.u.]')\na[2,0].text(0.5, 0.9, f'Speckle size: {speckle_size_original} pixels', color='red', transform=a[2,0].transAxes)\n\n# Plot the central slice of the filtered autocorrelation (zoomed)\na[2,1].plot(central_slice_filtered, color='black')\na[2,1].axhline(y=half_max_filtered, color='red', linestyle='--')\na[2,1].set_title('Central Slice of Filtered Autocorrelation')\na[2,1].set_xlabel('Pixel')\na[2,1].set_ylabel('Intensity [a.u.]')\na[2,1].text(0.5, 0.9, f'Speckle size: {speckle_size_filtered} pixels', color='red', transform=a[2,1].transAxes)\n\n# Adjust layout\nplt.tight_layout()\n# Save the plot\nplt.savefig('images/LSCISimulation.png')\nplt.close(fig)\n\n\n\n\n\n\n\n\nFigure 5.2: The simulated and filtered speckle images.\n\n\n\nAs the cutoff frequency decreases, the size of the speckle in pixels increases. The original speckle pattern has a speckle size of 1. A cutoff frequency of N/4 results in a filtered speckle size of 2 pixels, N/8 results in a filtered speckle size of 4 pixels, and N/16 results in a filtered speckle size of 8 pixels, as shown in Figures 5.7, 5.8, and 5.9. This implies that the filter size directly affects the resulting speckle size and a more narrow filter will produce a lower resolution image, but may decrease the noise in the speckle pattern. Additionally, as the filter’s cutoff frequency decreases, the amplitude histogram of the filtered patterns intensity decreases. Fig. 5.7 shows a normalized amplitude peak at approximately 1 for a cutoff frequency of N/4, while Fig. 5.9 shows an amplitude peak at 0.1 for a cutoff frequency of N/16. The simulated results also show an increase in autocorrelation with a decrease in cutoff frequency. The change in autocorrelation is indicative of the change in speckle size across the simulations. In real-world applications, an increase in autocorrelation across images may also imply differences in the subject’s roughness or uniformity.\n\n\n\n5.3.2 Physical Tests\nThe LSCI analysis script was run on images with a cream and water mixture running through the tube at flow rates of 0 ml/hr, 50 ml/hr, 100 ml/hr, 150 ml/hr, and 200 ml/hr. The resulting speckle images, LSCI reproductions and LSCI K values are shown in Fig. 5.10 and Table 5.1. While there is a general decreasing trend in the K values as flow rate decreases, there are discrepancies from value to value.\n\nFinding the moving LSCI K value\n\n\nShow code from speckle_an.py\nfrom PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nimport cv2\nfrom scipy.ndimage import gaussian_filter\nimport os\nimport pandas as pd\n\n# Load BMP image and convert to grayscale numpy array\ndef load_and_normalize_image(image_path):\n    img = Image.open(image_path).convert('L')\n    img_array = np.array(img)\n    # Normalize the image to range [0, 1]\n    img_normalized = img_array / 255.0\n    return img_normalized\n\n# Function for Fourier Transform\ndef ft2(im):\n    return np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(im)))\n\n# Function for Inverse Fourier Transform\ndef ift2(im):\n    return np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(im)))\n\n# Calculate speckle contrast\ndef calcSpeckleContrast(image_path):\n    x1 = 2150; x2 = 2600\n    y1 = 1200; y2 = 1600  \n\n    image = plt.imread(image_path)\n    intensity = np.asarray(image[y1:y2, x1:x2])\n    photo = gaussian_filter(intensity, 2)\n\n    window = photo[:][:]\n    w_dev = np.std(window)\n    w_meanInt = np.mean(window)\n    w_speckle_contrast = w_dev / w_meanInt \n    \n    # the selection of SQUARE x SQUARE pixels where speckle will be calculated\n    SQUARE = 7\n    \n    # convert photo into an np array\n    pArr = np.asarray(photo)\n    \n    # the speckle contrast array that will be returned\n    contrast_array = [ [0]*(len(pArr[0])-SQUARE) for i in range((len(pArr))-SQUARE) ]\n    conMin = np.inf;\n    \n    # The Loop Does the Following:\n    # goes through 7x7 selections of the image\n    # computes the speckle contrast for this region\n    # using this comparison, create a new matrix with values whose magnitude\n        # decreases depending on how \"blurry\" the selection is\n    for r in range(len(pArr) - SQUARE):\n        for c in range(len(pArr[0]) - SQUARE):\n            x1 = r; x2 = r+SQUARE-1\n            y1 = c; y2 = c+SQUARE-1\n            selection = pArr[x1:x2, y1:y2]\n            \n            s_dev = np.std(selection)\n            s_meanInt = np.mean(selection)\n            \n            # to cut out values outside of the speckle caught on camera\n            #if (s_meanInt &lt;= 0.1 and s_dev &lt;= 0.1):\n              # contrast_array[r][c] = np.NaN\n            #else:\n            s_speckle_contrast = s_dev / s_meanInt\n                \n            if s_speckle_contrast &lt; conMin and s_speckle_contrast != 0:\n                conMin = s_speckle_contrast\n                    \n            contrast_array[r][c] = s_speckle_contrast\n    \n    conArr = np.asarray(contrast_array)\n    conArr[conArr == 0] = conMin\n    \n    return (w_speckle_contrast, contrast_array)\n\ndef calcSpeckleContrastVal(image_path):\n    x1 = 2150; x2 = 2600\n    y1 = 1200; y2 = 1600  \n\n    image = plt.imread(image_path)\n    intensity = np.asarray(image[y1:y2, x1:x2])\n   \n    stat_x1 = 0; stat_x2 = 50\n    stat_y1 = 0; stat_y2= 50\n\n    mov_x1 = 0; mov_x2 = 50\n    mov_y1 = 200; mov_y2 = 250      \n\n    filtered = gaussian_filter(intensity, 2)\n\n    static_window = np.asarray(filtered[stat_y1:stat_y2,stat_x1:stat_x2])\n    stat_con = np.std(static_window) / np.mean(static_window)\n    moving_window = np.asarray(filtered[mov_y1:mov_y2,mov_x1:mov_x2])\n    move_con = np.std(moving_window) / np.mean(moving_window)\n\n    return (move_con, stat_con)\n\ndef process_images(folder_path):\n    results = {}\n\n    # Iterate through the folder and process images\n    for filename in os.listdir(folder_path):\n        if filename.endswith('.bmp'):\n            # Extract flowrate and exposure time from the filename\n            parts = filename.split('_')\n            flowrate = parts[1]  # Assuming flowrate is the first part\n            exposure_time = parts[2]  # Assuming exposure time is the second part\n\n            # Initialize the flowrate in results dictionary if not already\n            if flowrate not in results:\n                results[flowrate] = {}\n\n            # Initialize the exposure time in the flowrate dictionary if not already\n            if exposure_time not in results[flowrate]:\n                results[flowrate][exposure_time] = []\n\n            # Get the LSCI from the image\n            move_con, stat_con = calcSpeckleContrastVal(os.path.join(folder_path, filename))\n            \n            results[flowrate][exposure_time].append(move_con)\n\n    # Calculate the average for each exposure time within each flowrate\n    averages = {}\n    stds = {}\n    for flowrate, exposure_times in results.items():\n        averages[flowrate] = {}\n        for exposure_time, values in exposure_times.items():\n            averages[flowrate][exposure_time] = np.mean(values)\n    \n    # Convert results to DataFrame for saving\n    df = pd.DataFrame.from_dict({(flowrate, exposure_time): avg \n                                  for flowrate, exposure_times in averages.items() \n                                  for exposure_time, avg in exposure_times.items()},\n                                 orient='index', columns=['Average Value']).reset_index()\n\n    # Split the MultiIndex into separate columns\n    df[['Flowrate', 'Exposure Time']] = pd.DataFrame(df['index'].tolist(), index=df.index)\n\n    # Drop the original index column\n    df.drop('index', axis=1, inplace=True)\n\n    # Rearrange columns\n    df = df[['Flowrate', 'Exposure Time', 'Average Value']]\n    df.to_csv(folder_path + '/averages.csv', index=False)\n\n\n# RUN CODE\n\nfolder_path = 'Data/0.001s'\nprocess_images(folder_path)\n\n#| label: tbl-planets\n#| tbl-cap: Average K value for 0.001s Exposure Time\n\nfrom IPython.display import Markdown\nfrom tabulate import tabulate\n\n# Display the csv as a Markdown table\n\ntable = pd.read_csv('Data/0.001s/averages.csv')\nMarkdown(tabulate(\n  table, \n  headers=[\"Flowrate [ml/hr]\",\"Exposure Time [s]\", \"Average K [a.u.]\"]\n))\n\n\n\n\n\n\nFlowrate [ml/hr]\nExposure Time [s]\nAverage K [a.u.]\n\n\n\n\n0\n200ml\n0.001\n0.365206\n\n\n1\n50ml\n0.001\n0.367474\n\n\n2\n100ml\n0.001\n0.332304\n\n\n3\n0ml\n0.001\n0.365184\n\n\n4\n238ml\n0.001\n0.359352\n\n\n5\n150ml\n0.001\n0.371385\n\n\n\n\n\n\n\nFinding the LSCI Reproduction of Different Flowrates\n\n\nShow code from speckle_an.py\nimage_path1 = 'Data/0.001s/LSCI_0ml_0.001_1.bmp'\nimage_path2 = 'Data/0.001s/LSCI_50ml_0.001_1.bmp'\nimage_path3 = 'Data/0.001s/LSCI_100ml_0.001_1.bmp'\nimage_path4 = 'Data/0.001s/LSCI_150ml_0.001_1.bmp'\nimage_path5 = 'Data/0.001s/LSCI_200ml_0.001_1.bmp'\n\nx1 = 2150; x2 = 2600\ny1 = 1200; y2 = 1600  \n\n\n# Plot the Original Speckle Image\noriginal = Image.open(image_path4).convert('L')\nog_int = np.asarray(original)\nog_int = og_int[y1:y2, x1:x2]\n\n# Plot the speckle contrast\n\n(cont1, contrast_array1) = calcSpeckleContrast(image_path1)\n(cont2, contrast_array2) = calcSpeckleContrast(image_path2)\n(cont3, contrast_array3) = calcSpeckleContrast(image_path3)\n(cont4, contrast_array4) = calcSpeckleContrast(image_path4)\n(cont5, contrast_array5) = calcSpeckleContrast(image_path5)\n\nfig, ax = plt.subplots(nrows=2, ncols=3, figsize=(12, 4))\n\nim0 = ax[0,0].imshow(og_int, cmap = 'gray', vmin=0, vmax=255)\nax[0,0].set_title(\"(a) Intensity of Laser Speckle for 150 ml/hr\", fontsize = 8)\ndivider0 = make_axes_locatable(ax[0, 0])\ncax0 = divider0.append_axes(\"right\", size=\"5%\", pad=0.05)\ncbar0 = fig.colorbar(im0, cax=cax0)\ncbar0.set_label('Intensity [a.u.]')\n\nim1 = ax[0,1].imshow(contrast_array1, cmap = \"jet\")\nax[0,1].set_title(f'(b) Speckle Contrast of Laser Speckle for 0 ml/hr', fontsize = 8)\ndivider1 = make_axes_locatable(ax[0, 1])\ncax1 = divider1.append_axes(\"right\", size=\"5%\", pad=0.05)\ncbar1 = fig.colorbar(im1, cax=cax1)\ncbar1.set_label('Speckle Contrast K [a.u.]')\n\nim2 = ax[0,2].imshow(contrast_array2, cmap = \"jet\")\nax[0,2].set_title(f'(c) Speckle Contrast of Laser Speckle for 50 ml/hr', fontsize = 8)\ndivider2 = make_axes_locatable(ax[0, 2])\ncax2 = divider2.append_axes(\"right\", size=\"5%\", pad=0.05)\ncbar2 = fig.colorbar(im2, cax=cax2)\ncbar2.set_label('Speckle Contrast K [a.u.]')\n\nim3 = ax[1,0].imshow(contrast_array3, cmap = \"jet\")\nax[1,0].set_title(f'(c) Speckle Contrast of Laser Speckle for 100 ml/hr', fontsize = 8)\ndivider3 = make_axes_locatable(ax[1,0])\ncax3 = divider3.append_axes(\"right\", size=\"5%\", pad=0.05)\ncbar3 = fig.colorbar(im3, cax=cax3)\ncbar3.set_label('Speckle Contrast K [a.u.]')\n\nim4 = ax[1,1].imshow(contrast_array4, cmap = \"jet\")\nax[1,1].set_title(f'(e) Speckle Contrast of Laser Speckle for 150 ml/hr', fontsize = 8)\ndivider4 = make_axes_locatable(ax[1,1])\ncax4 = divider4.append_axes(\"right\", size=\"5%\", pad=0.05)\ncbar4 = fig.colorbar(im4, cax=cax4)\ncbar4.set_label('Speckle Contrast K [a.u.]')\n\nim5 = ax[1,2].imshow(contrast_array5, cmap = \"jet\")\nax[1,2].set_title(f'(f) Speckle Contrast of Laser Speckle for 200 ml/hr', fontsize = 8)\ndivider5 = make_axes_locatable(ax[1,2])\ncax5 = divider5.append_axes(\"right\", size=\"5%\", pad=0.05)\ncbar5 = fig.colorbar(im5, cax=cax5)\ncbar5.set_label('Speckle Contrast K [a.u.]')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save the plot\nplt.savefig('images/LSCIReal.png')\nplt.close(fig)\n\n\n\n\n\n\n\n\nFigure 5.3: The real-world results for LSCI on a 150 ml/hr fluid.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "sections/results/results.html#additional-capabilities",
    "href": "sections/results/results.html#additional-capabilities",
    "title": "5  Results",
    "section": "5.4 Additional Capabilities",
    "text": "5.4 Additional Capabilities\nThe system was successful in taking time lapse images over an extended period of time and could be used for a broad range of biological imaging applications. The time lapse of the Tobacco Hornworm growth resulted in 45 images over the span of 9 days, with 5 hours between each image. An example of one week’s worth of growth is shown in Fig. 5.11, and an image of the full box on the first and last day is shown in Fig. 5.12.\n\n\n\n\n\n\nFigure 5.4: A week’s worth of growth from one hornworm.\n\n\n\nWhile the OpenIVIS system was able to take images of lettuce leaf decomposition over a three day period, the anthocyanin response was not able to be determined. The response imaged on the 1st and 3rd days of the trial are shown in Fig. # and #. The anthocyanin response is very similar between the two images, and discernible changes are not able to be visualized. It is possible that the type of lettuce being imaged does not have a strong enough concentration of anthocyanin to properly fluoresce, resulting in similar results. Additionally, due to limited documentation on how to conduct this experiment, the experimental process and calculations used may be incorrect. An accurate depiction of this trial is shown in the system’s previous publication by Branning et. al [Branning].\n\n\n\n\n[1] S. W. Hasinoff, “Saturation (imaging),” in Computer vision: A reference guide, Springer, 2021, pp. 1107–1109.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "sections/conclusion/index.html",
    "href": "sections/conclusion/index.html",
    "title": "6  Conclusion",
    "section": "",
    "text": "7 Conclusion\nThe conclusion summaries the main results of your paper. It generally mirrors the abstract, but in slightly more detail.\nIt is also common for the conclusion to include a discussion of the data, limitations of the work, and directions for future work.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Conclusion</span>"
    ]
  },
  {
    "objectID": "sections/acknowledgements/index.html",
    "href": "sections/acknowledgements/index.html",
    "title": "7  Acknowledgments",
    "section": "",
    "text": "This research was supported by the Silicon Valley Community Foundation under Grant No. 2022-251322. The authors would like to thank the Colorado School of Mines Cash Lab, Harvey Mudd College, Daniel A. Guerra, Jenny Nguyen, Xavier Walter, and Jacob Staimpel for their support and collaboration.\n\nDaniel A. Guerra - HMC Chemistry Laboratory and Stockroom Manager\nJenny Nguyen - HMC Biology Laboratory Manager\nXavier Walter - HMC Staff Engineer\nJacob Staimpel - HMC Engineering Instructional Support Coordinator",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Acknowledgments</span>"
    ]
  },
  {
    "objectID": "sections/appendix/index.html",
    "href": "sections/appendix/index.html",
    "title": "8  Appendix",
    "section": "",
    "text": "8.1 Bill of Materials",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "sections/appendix/index.html#python-packages",
    "href": "sections/appendix/index.html#python-packages",
    "title": "8  Appendix",
    "section": "8.2 Python Packages",
    "text": "8.2 Python Packages",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "sections/appendix/index.html#python-code",
    "href": "sections/appendix/index.html#python-code",
    "title": "8  Appendix",
    "section": "8.3 Python Code",
    "text": "8.3 Python Code",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "sections/appendix/index.html#cad-files",
    "href": "sections/appendix/index.html#cad-files",
    "title": "8  Appendix",
    "section": "8.4 CAD Files",
    "text": "8.4 CAD Files",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Appendix</span>"
    ]
  }
]